#!/usr/bin/env bash

#needs to increment on every change!!!
#version: 57

# ============================================================================
# Constants
# ============================================================================
readonly DEFAULT_DOCKER_IMAGE_REGISTRY="ghcr.io/spring-media"
readonly DEFAULT_DOCKER_IMAGE_NAME=maps-tools
readonly DEFAULT_DOCKER_IMAGE_TAG=latest
readonly DEFAULT_DOCKER_USERNAME=k8s
readonly DEFAULT_DOCKER_IMAGE="${DEFAULT_DOCKER_IMAGE_REGISTRY}/${DEFAULT_DOCKER_IMAGE_NAME}"

# ============================================================================
# Global Variables
# ============================================================================
INTERACTIVE_IMAGE_SELECTION=false
AWS_PROFILE_STAGE=$AWS_PROFILE
MOUNT_AWS_CONFIGS=true
RUN_AS_DAEMON=false
ATTACH_TO_DAEMON=false
EXEC_IN_DAEMON=false
PERFORM_UPDATE=false
PERFORM_CONFIG_CLEANUP=false
USE_SESSION_KUBECONFIG=false
ENABLE_K8S_DASHBOARD=false
RELEASE_CHANNEL=
CURRENT_USER=${HOME##*/}
DOCKER_IS_RUNNING=false

declare -a EXTRA_DOCKER_ARGS
declare -a AVAILABLE_PORTS

# ============================================================================
# Initialization
# ============================================================================

# Ensure required directories and files exist
[ ! -f "$HOME/.terraformrc" ] && touch "$HOME/.terraformrc"
[ ! -d "$HOME/.spacelift" ] && mkdir -p "$HOME/.spacelift"

# Find 5 available ports in range 8000-8999
for port in {8000..8999}; do
  nc -z 127.0.0.1 "${port}" -w2 2>/dev/null && continue
  AVAILABLE_PORTS+=("${port}")
  [ "${#AVAILABLE_PORTS[@]}" -eq 5 ] && break
  [ "${port}" -eq 8999 ] && echo "All local ports 8000-8999 are in use" && exit 1
done

# ============================================================================
# Helper Functions
# ============================================================================

function print_usage() {
  cat <<EOF

maps-tools - Docker-based tooling environment for AWS, Kubernetes, and Terraform

USAGE:
  $0 [OPTIONS]

COMMON OPTIONS:
  -h              Show this help message and exit
  --version       Print version number and exit

ENVIRONMENT OPTIONS:
  -e PROFILE      Set AWS profile/environment (e.g., mediasites-stage.dev)
                  Default: Uses \$AWS_PROFILE if set

CONTAINER MODES:
  (default)       Run interactive container (removed after exit)
  -d              Create persistent daemon container in background
  -a              Attach to existing daemon container
  -E              Execute command in existing daemon container

CONFIGURATION:
  -v              Skip mounting local config directories (.aws, .ssh, .helm, .kube)
                  Use when you want an isolated container environment
  -s              Use session-specific kubeconfig instead of shared config
  -c              Backup and cleanup AWS and Kubernetes config files
                  Creates timestamped backups before removal

DOCKER OPTIONS:
  -i              Interactively select from locally available Docker images
  -o "ARGS"       Pass additional arguments to docker run/create
                  Can be used multiple times. Example: -o "-p 8080:8080"

FEATURES:
  -x              Enable Kubernetes dashboard (Octant) at http://0.0.0.0:7777/
  -u [VERSION]    Check for script and Docker image updates, optionally install
                  Checks both the maps-tools script and Docker image
                  Optional: -u testing (for testing release channel)

EXAMPLES:
  # Run standard interactive container
  $0

  # Run with specific AWS profile
  $0 -e mediasites-prod.admin

  # Create background daemon container
  $0 -d

  # Attach to running daemon
  $0 -a

  # Run with Kubernetes dashboard
  $0 -x

  # Expose additional port and set environment variable
  $0 -o "-p 9090:9090" -o "-e MY_VAR=value"

  # Check for updates
  $0 -u

NOTES:
  - Daemon mode (-d) and attach mode (-a) are mutually exclusive
  - The container automatically mounts your home directory and configs
  - Five random ports (8000-8999) are automatically exposed
  - Use -v to prevent mounting configs for a clean environment

For more information, visit: https://github.com/spring-media/maps-tools

EOF
  exit 0
}

# Check if container exists and its state
function get_container_state() {
  local name="$1"
  if docker ps --format "{{.Names}}" --filter "name=${name}" 2>/dev/null | grep -q "^${name}$"; then
    echo "running"
  elif docker ps -a --format "{{.Names}}" --filter "name=${name}" 2>/dev/null | grep -q "^${name}$"; then
    echo "stopped"
  else
    echo "none"
  fi
}

# Add volume mounts to docker command array
function add_volume_mounts() {
  DOCKER_CMD+=("-v" "$HOME:/home/$CURRENT_USER")
  
  if [ "${MOUNT_AWS_CONFIGS}" = "true" ]; then
    DOCKER_CMD+=("-v" "$HOME/.aws:/home/$DEFAULT_DOCKER_USERNAME/.aws")
    DOCKER_CMD+=("-v" "$HOME/.ssh:/home/$DEFAULT_DOCKER_USERNAME/.ssh")
    DOCKER_CMD+=("-v" "$HOME/.helm:/home/$DEFAULT_DOCKER_USERNAME/.helm")
    DOCKER_CMD+=("-v" "$HOME/.kube:/home/$DEFAULT_DOCKER_USERNAME/.kube")
    DOCKER_CMD+=("-v" "$HOME/.spacelift:/home/$DEFAULT_DOCKER_USERNAME/.spacelift")
    DOCKER_CMD+=("-v" "$HOME/.terraformrc:/home/$DEFAULT_DOCKER_USERNAME/.terraformrc")
  fi
}

# Add port mappings to docker command array
function add_port_mappings() {
  for port in ${AVAILABLE_PORTS[@]}; do
    DOCKER_CMD+=("-p" "${port}:${port}")
  done
}

# Add environment variables to docker command array
function add_environment_vars() {
  local container_start_path="$PWD"
  if echo "$container_start_path" | grep -q "$HOME"; then
    container_start_path=$(echo "$container_start_path" | sed "s|Users|home|")
  else
    container_start_path="/home/$USER"
  fi
  
  DOCKER_CMD+=("-e" "AWS_PROFILE=$AWS_PROFILE_STAGE")
  DOCKER_CMD+=("-e" "DEFAULT_SESSION_KUBECONFIG=$USE_SESSION_KUBECONFIG")
  DOCKER_CMD+=("-e" "START_PATH=$container_start_path")
  DOCKER_CMD+=("-e" "K8S_DASHBOARD=$ENABLE_K8S_DASHBOARD")
  
  if [ ${#AVAILABLE_PORTS[@]} -gt 0 ]; then
    DOCKER_CMD+=("-e" "PORT_VARIABLE=${AVAILABLE_PORTS[*]}")
  fi
  
  if [ "${ENABLE_K8S_DASHBOARD}" = "true" ]; then
    DOCKER_CMD+=("-e" "OCTANT_LISTENER_ADDR=0.0.0.0:7777")
    DOCKER_CMD+=("-p" "7777:7777")
  fi
}

# Build complete Docker command based on operation mode
function build_docker_command() {
  if [ $# -lt 1 ]; then
    echo "‚ùå No image name provided"
    return 1
  fi
  
  local image_name="$1"
  shift
  local command_to_exec="$*"
  local container_state=$(get_container_state "maps-tools")
  
  DOCKER_CMD=()
  
  # Build command based on operation mode
  if [ "${RUN_AS_DAEMON}" = "true" ]; then
    if [ "$container_state" != "none" ]; then
      docker rm -f maps-tools >/dev/null 2>&1
    fi
    DOCKER_CMD=(docker create --name maps-tools)
    add_volume_mounts
    add_port_mappings
    add_environment_vars
    DOCKER_CMD+=("${EXTRA_DOCKER_ARGS[@]}")
    DOCKER_CMD+=(--entrypoint "/init/init_daemon.sh" "$image_name")
                
  elif [ "${ATTACH_TO_DAEMON}" = "true" ]; then
    if [ "$container_state" = "running" ]; then
      DOCKER_CMD=(docker exec -ti)
      DOCKER_CMD+=("-e" "AWS_PROFILE=$AWS_PROFILE_STAGE")
      DOCKER_CMD+=("-e" "DEFAULT_SESSION_KUBECONFIG=$USE_SESSION_KUBECONFIG")
      container_start_path="$PWD"
      if echo "$container_start_path" | grep -q "$HOME"; then
        container_start_path=$(echo "$container_start_path" | sed "s|Users|home|")
      else
        container_start_path="/home/$USER"
      fi
      DOCKER_CMD+=("-e" "START_PATH=$container_start_path")
      DOCKER_CMD+=("${EXTRA_DOCKER_ARGS[@]}")
      DOCKER_CMD+=(maps-tools /usr/bin/bash --login)
    elif [ "$container_state" = "stopped" ]; then
      docker start maps-tools
      DOCKER_CMD=(docker exec -ti)
      DOCKER_CMD+=("-e" "AWS_PROFILE=$AWS_PROFILE_STAGE")
      DOCKER_CMD+=("-e" "DEFAULT_SESSION_KUBECONFIG=$USE_SESSION_KUBECONFIG")
      container_start_path="$PWD"
      if echo "$container_start_path" | grep -q "$HOME"; then
        container_start_path=$(echo "$container_start_path" | sed "s|Users|home|")
      else
        container_start_path="/home/$USER"
      fi
      DOCKER_CMD+=("-e" "START_PATH=$container_start_path")
      DOCKER_CMD+=("${EXTRA_DOCKER_ARGS[@]}")
      DOCKER_CMD+=(maps-tools /init/init.sh)
    else
      echo "‚ùå No container named maps-tools found to attach to"
      return 1
    fi
    
  elif [ "${EXEC_IN_DAEMON}" = "true" ]; then
    if [ "$container_state" = "none" ]; then
      echo "‚ùå No container named maps-tools found"
      return 1
    fi
    
    if [ "$container_state" = "stopped" ]; then
      docker start maps-tools
    fi
    
    DOCKER_CMD=(docker exec -t)
    DOCKER_CMD+=("-e" "AWS_PROFILE=$AWS_PROFILE_STAGE")
    DOCKER_CMD+=("-e" "DEFAULT_SESSION_KUBECONFIG=$USE_SESSION_KUBECONFIG")
    container_start_path="$PWD"
    if echo "$container_start_path" | grep -q "$HOME"; then
      container_start_path=$(echo "$container_start_path" | sed "s|Users|home|")
    else
      container_start_path="/home/$USER"
    fi
    DOCKER_CMD+=("-e" "START_PATH=$container_start_path")
    DOCKER_CMD+=("${EXTRA_DOCKER_ARGS[@]}")
    DOCKER_CMD+=(maps-tools /usr/bin/bash --login -c "$command_to_exec")
    echo "DEBUG: Executing: ${DOCKER_CMD[*]}" >&2
    
  else
    # Standard interactive container run
    DOCKER_CMD=(docker run -it --rm)
    add_volume_mounts
    add_port_mappings
    add_environment_vars
    DOCKER_CMD+=("${EXTRA_DOCKER_ARGS[@]}")
    DOCKER_CMD+=("$image_name")
  fi
}

# Validate that mutually exclusive options aren't used together
function validate_mutually_exclusive_options() {
  local active_mode_count=0
  [[ "${RUN_AS_DAEMON}" == true ]] && ((active_mode_count++))
  [[ "${ATTACH_TO_DAEMON}" == true ]] && ((active_mode_count++))
  [[ "${EXEC_IN_DAEMON}" == true ]] && ((active_mode_count++))
  
  if [[ $active_mode_count -gt 1 ]]; then
    echo "‚ùå Options -d, -a, and -E are mutually exclusive"
    exit 1
  fi
}

function run_container() {
  validate_mutually_exclusive_options
  
  local selected_image="${DEFAULT_DOCKER_IMAGE}:${DEFAULT_DOCKER_IMAGE_TAG}"

  if [ "${INTERACTIVE_IMAGE_SELECTION}" = "true" ]; then
    available_images=$(docker images | grep "${DEFAULT_DOCKER_IMAGE_NAME}" | awk '{ print $1 ":" $2 }')
    
    if [ -z "$available_images" ]; then
      echo "‚ùå No local images found. Run 'make build' or pull from registry"
      exit 1
    fi
    
    PS3="Choose the image to run: "
    select selected_image in $available_images; do
      if [ -n "$selected_image" ]; then
        break
      else
        echo "‚ùå Invalid choice"
        exit 1
      fi
    done
  else
    check_and_prompt_for_updates
  fi
  
  build_docker_command "$selected_image" "$@"
  "${DOCKER_CMD[@]}"
}

# ============================================================================
# Update & Installation Functions
# ============================================================================

function download_latest_script() {
  local source_url="https://raw.githubusercontent.com/spring-media/maps-tools-install/main/maps-tools${RELEASE_CHANNEL}"
  
  # Use local copy in development context
  if [[ -f ./maps-tools && -d ./.git && -x /usr/local/bin/maps-tools ]]; then
    cp -f ./maps-tools /tmp/maps-tools || { echo "‚ùå Failed to copy local script"; exit 1; }
  else
    curl -sf "$source_url" >/tmp/maps-tools || { echo "‚ùå Failed to download from $source_url"; exit 1; }
  fi
  
  # Validate downloaded script
  [[ ! -s /tmp/maps-tools ]] && echo "‚ùå Downloaded script is empty" && rm -f /tmp/maps-tools && exit 1
  grep -q "#version:" /tmp/maps-tools || { echo "‚ùå Script corrupted (no version found)"; rm -f /tmp/maps-tools; exit 1; }
}

function install_script_to_system() {
  [[ ! -f /tmp/maps-tools ]] && echo "‚ùå No script found for installation" && exit 1
  
  echo "Installing maps-tools to /usr/local/bin (may require password)"
  cp -f /tmp/maps-tools /usr/local/bin/maps-tools 2>/dev/null || \
    sudo cp -f /tmp/maps-tools /usr/local/bin/maps-tools
  chmod 755 /usr/local/bin/maps-tools 2>/dev/null || \
    sudo chmod 755 /usr/local/bin/maps-tools
}

function check_docker_image_update() {
  local image_tag="${RELEASE_CHANNEL#-}"
  [[ -z "$image_tag" ]] && image_tag="${DEFAULT_DOCKER_IMAGE_TAG}"
  local full_image="${DEFAULT_DOCKER_IMAGE}:${image_tag}"
  
  if [[ "$image_tag" == "${DEFAULT_DOCKER_IMAGE_TAG}" ]]; then
    echo "Checking for Docker image updates..."
  else
    echo "Checking for Docker image updates (${image_tag})..."
  fi
  
  # Get local image digest if it exists
  local local_digest=$(docker images --no-trunc --format "{{.ID}}" "${full_image}" 2>/dev/null | head -n1)
  
  if [[ -z "$local_digest" ]]; then
    echo "No local Docker image found. Pulling ${full_image}..."
    docker pull "${full_image}"
    return 0
  fi
  
  # Get remote manifest digest without pulling the full image
  echo "Checking remote registry for updates..."
  local remote_digest=$(docker manifest inspect "${full_image}" 2>/dev/null | grep -m1 '"digest":' | sed 's/.*"sha256:\([^"]*\)".*/sha256:\1/')
  
  if [[ -z "$remote_digest" ]]; then
    echo "‚ö†Ô∏è  Unable to check for Docker image updates (network or registry issue)"
    return 1
  fi
  
  # Compare digests
  if [[ "$local_digest" != "$remote_digest" ]]; then
    echo "üîÑ New Docker image available: ${full_image}"
    read -p "Do you want to download the new image? (y/n) " response
    if [[ "$response" == "y" || "$response" == "Y" ]]; then
      echo "Downloading new image..."
      docker pull "${full_image}"
      echo "‚úÖ Docker image updated successfully"
    else
      echo "Skipping image download. Run 'maps-tools -u' to update later."
    fi
    return 0
  else
    echo "‚úÖ Docker image is up to date: ${full_image}"
    return 0
  fi
}

function check_and_prompt_for_updates() {
  download_latest_script
  
  local installed_version=$(grep -m 1 "#version:" /usr/local/bin/maps-tools 2>/dev/null | awk '{print $2}')
  local available_version=$(grep -m 1 "#version:" /tmp/maps-tools | awk '{print $2}')
  local script_updated=false
  
  if [[ -n "$installed_version" && -n "$available_version" && "$installed_version" -lt "$available_version" ]]; then
    read -p "New version available ($installed_version ‚Üí $available_version). Update? (y/n) " response
    if [[ "$response" == "y" ]]; then
      echo "Upgrading to version ${available_version}"
      install_script_to_system
      script_updated=true
    fi
  else
    echo "maps-tools script is up to date (v${installed_version})"
  fi
  
  rm -f /tmp/maps-tools
  
  # Always check for Docker image updates when -u is called
  echo ""
  check_docker_image_update
  
  if [[ "$script_updated" == true ]]; then
    echo ""
    echo "‚úÖ Update complete! Please restart your shell or run the command again."
  fi
}

function pull_docker_image() {
  local image_tag="${RELEASE_CHANNEL#-}"
  [[ -z "$image_tag" ]] && image_tag="${DEFAULT_DOCKER_IMAGE_TAG}"
  docker pull "${DEFAULT_DOCKER_IMAGE}:${image_tag}"
}

# ============================================================================
# Configuration Management
# ============================================================================

function parse_optional_argument() {
  eval next_token=\${$OPTIND}
  if [[ -n $next_token && $next_token != -* ]]; then
    OPTIND=$((OPTIND + 1))
    OPTARG=$next_token
  else
    OPTARG=""
  fi
}

function backup_config_file() {
  local filepath="$1"
  [[ ! -s "$filepath" ]] && return
  local timestamp=$(date +%Y%m%d%H%M%S)
  local backup_path="${filepath}-${timestamp}"
  echo "Backing up $filepath to $backup_path"
  mv -f "$filepath" "$backup_path"
}

function backup_all_configs() {
  backup_config_file "${HOME}/.aws/config"
  backup_config_file "${HOME}/.aws/credentials"
  backup_config_file "${HOME}/.aws/awsctx"
  backup_config_file "${HOME}/.kube/config"
  
  for config_file in ${HOME}/.kube/*config-*; do
    [[ -s "$config_file" ]] || continue
    local timestamp=$(date +%Y%m%d%H%M%S)
    local filename="${config_file##*/}"
    local backup_path="${config_file%/*}/backup-${filename#*config-}-${timestamp}"
    echo "Backing up $config_file to $backup_path"
    mv -f "$config_file" "$backup_path"
  done
}

# ============================================================================
# Main Script Logic
# ============================================================================

# Auto-detect release channel from script name if not already set
if [[ -z "$RELEASE_CHANNEL" ]]; then
  script_name="${0##*/}"
  if [[ "$script_name" == "maps-tools-testing" ]]; then
    RELEASE_CHANNEL="-testing"
  elif [[ "$script_name" =~ ^maps-tools-(.+)$ ]]; then
    RELEASE_CHANNEL="-${BASH_REMATCH[1]}"
  fi
fi

# Handle version flag
[[ "$1" == "--version" ]] && echo "maps-tools version: $(grep -m 1 "#version:" "$0" | awk '{print $2}')" && exit 0

# Parse command line options
while getopts "b:o:he:ivdaucsxE" arg; do
  case "${arg}" in
    b) echo "üõ†Ô∏è  TODO: Build args not yet implemented" ;;
    e) AWS_PROFILE_STAGE="${OPTARG}" ;;
    v) MOUNT_AWS_CONFIGS=false ;;
    i) INTERACTIVE_IMAGE_SELECTION=true ;;
    d) RUN_AS_DAEMON=true ;;
    a) ATTACH_TO_DAEMON=true ;;
    E) EXEC_IN_DAEMON=true ;;
    c) PERFORM_CONFIG_CLEANUP=true ;;
    s) USE_SESSION_KUBECONFIG=true ;;
    u)
      parse_optional_argument "$@"
      RELEASE_CHANNEL="${OPTARG:+-${OPTARG}}"
      PERFORM_UPDATE=true
      ;;
    o) EXTRA_DOCKER_ARGS+=("$OPTARG") ;;
    x) ENABLE_K8S_DASHBOARD=true ;;
    h|?|*) print_usage ;;
  esac
done
shift $((OPTIND - 1))

# Handle initial installation
if [[ ! -x /usr/local/bin/maps-tools ]]; then
  echo "Installing maps-tools to /usr/local/bin"
  download_latest_script
  install_script_to_system
  rm -f /tmp/maps-tools
  
  cat <<EOF

Add /usr/local/bin to your \$PATH:

bash:  echo 'export PATH="/usr/local/bin:\$PATH"' >> ~/.bashrc && source ~/.bashrc
zsh:   echo 'export PATH="/usr/local/bin:\$PATH"' >> ~/.zshrc && source ~/.zshrc

EOF
  exit 0
fi

# Handle update request
if [[ "$PERFORM_UPDATE" == true ]] || [[ "${0##*/}" != "maps-tools" ]]; then
  check_and_prompt_for_updates
  exit 0
fi

# Handle config cleanup
if [[ "$PERFORM_CONFIG_CLEANUP" == true ]]; then
  read -p "Are you sure you want to backup and cleanup .aws and .kube configs? (y/n) " response
  [[ "$response" == [Yy]* ]] && backup_all_configs || echo "Cleanup cancelled"
  exit 0
fi

# Verify Docker installation
if [[ ! -d "/Applications/Rancher Desktop.app" && ! -d "/Applications/Docker.app" ]]; then
  echo "‚ö†Ô∏è  Warning: Rancher Desktop or Docker Desktop not found (officially supported)"
fi

# Start Docker if needed
function is_docker_running() {
  lsof -U 2>/dev/null | grep -q docker.sock
}

if is_docker_running; then
  echo "Docker is running"
  DOCKER_IS_RUNNING=true
else
  # Try to start Docker
  if [[ -e "/Applications/Rancher Desktop.app" ]]; then
    echo "Starting Rancher Desktop (use dockerd runtime, not containerd)"
    open "/Applications/Rancher Desktop.app"
  elif [[ -e "/Applications/Docker.app" ]]; then
    echo "Starting Docker Desktop"
    open "/Applications/Docker.app"
  fi
  
  # Wait for Docker to start (up to 4 minutes)
  echo -n "Waiting for Docker"
  for ((attempt=0; attempt<48; attempt++)); do
    sleep 5
    echo -n "."
    if is_docker_running; then
      echo
      echo "Docker started successfully"
      DOCKER_IS_RUNNING=true
      sleep 5
      break
    fi
  done
  
  if [[ "$DOCKER_IS_RUNNING" != true ]]; then
    echo
    echo "‚ùå Failed to start Docker within timeout"
    exit 1
  fi
fi

# Run the Docker container
if [[ "$DOCKER_IS_RUNNING" == true ]]; then
  echo "üöÄ maps-tools v$(grep -m 1 "#version:" "$0" | awk '{print $2}')"
  run_container "$@"
fi
